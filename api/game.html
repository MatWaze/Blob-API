<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcendence Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-area {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }

        .lobby-panel {
            width: 300px;
            background: #2a2a2a;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
        }

        .game-canvas-container {
            position: relative;
        }

        #gameCanvas {
            border: 2px solid #00ff00;
            border-radius: 8px;
            background: #000;
            cursor: none;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .countdown {
            color: #ff4444;
            font-size: 48px;
        }

        .room-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .room-item {
            background: #3a3a3a;
            border: 1px solid #555;
            margin: 5px 0;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .room-item:hover {
            background: #4a4a4a;
        }

        .room-item.current {
            border-color: #00ff00;
            background: #1a3a1a;
        }

        .controls {
            margin: 10px 0;
        }

        .btn {
            background: #2a2a2a;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #00ff00;
            color: #000;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .input {
            background: #2a2a2a;
            border: 1px solid #555;
            color: #00ff00;
            padding: 8px;
            margin: 5px;
            border-radius: 4px;
            font-family: inherit;
        }

        .status {
            margin: 10px 0;
            padding: 10px;
            background: #3a3a3a;
            border-radius: 4px;
        }

        .players-list {
            margin: 10px 0;
        }

        .player-item {
            padding: 5px 10px;
            margin: 2px 0;
            background: #3a3a3a;
            border-radius: 4px;
        }

        .error {
            color: #ff4444;
        }

        .success {
            color: #44ff44;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>TRANSCENDENCE</h1>
            <div class="status" id="connectionStatus">Connecting...</div>
        </div>

        <div class="game-area">
            <div class="lobby-panel">
                <h3>Game Lobby</h3>
                
                <div class="controls">
                    <h4>Create Room</h4>
                    <input type="number" id="entryFee" class="input" placeholder="Entry Fee" value="0" min="0">
                    <input type="number" id="maxPlayers" class="input" placeholder="Max Players" value="4" min="2" max="8">
                    <button class="btn" id="createRoomBtn">Create Room</button>
                </div>

                <div class="controls">
                    <h4>Available Rooms</h4>
                    <button class="btn" id="refreshRoomsBtn">Refresh</button>
                    <div class="room-list" id="roomList"></div>
                </div>

                <div id="currentRoom" style="display: none;">
                    <h4>Current Room</h4>
                    <div id="roomInfo"></div>
                    <div class="players-list" id="playersList"></div>
                    <div class="controls">
                        <button class="btn" id="markReadyBtn" style="display: none;">Mark Ready</button>
                        <button class="btn" id="markWaitingBtn" style="display: none;">Mark Waiting</button>
                        <button class="btn" id="startGameBtn" style="display: none;">Start Game</button>
                        <button class="btn" id="leaveRoomBtn">Leave Room</button>
                    </div>
                </div>
            </div>

            <div class="game-canvas-container">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
                <div class="overlay" id="gameOverlay"></div>
            </div>
        </div>
    </div>

    <script>
        class GameClient {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.overlay = document.getElementById('gameOverlay');
                
                this.lobbyWs = null;
                this.gameWs = null;
                this.currentRoomId = null;
                this.isCreator = false;
                this.gameState = null;
                this.players = [];
                this.gameResults = null;
                
                this.mouseX = 0;
                this.mouseY = 0;
                this.lastMouseUpdate = 0;
                
                this.initializeWebSockets();
                this.setupEventListeners();
                this.startRenderLoop();
            }

            initializeWebSockets() {
                this.connectLobby();
            }

            connectLobby() {
                if (this.lobbyWs) {
                    this.lobbyWs.close();
                }

                this.lobbyWs = new WebSocket('ws://localhost:3000/ws/lobby');
                
                this.lobbyWs.onopen = () => {
                    this.updateStatus('Connected to lobby', 'success');
                    console.log('Lobby WebSocket connected');
                };

                this.lobbyWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleLobbyMessage(data);  // ← This processes the message
                    } catch (error) {
                        console.error('Error parsing lobby message:', error);
                    }
                };

                this.lobbyWs.onclose = () => {
                    this.updateStatus('Disconnected from lobby', 'error');
                    setTimeout(() => this.connectLobby(), 3000);
                };

                this.lobbyWs.onerror = (error) => {
                    console.error('Lobby WebSocket error:', error);
                    this.updateStatus('Lobby connection error', 'error');
                };
            }

            connectGame() {
                if (!this.currentRoomId) return;

                if (this.gameWs) {
                    this.gameWs.close();
                }

                this.gameWs = new WebSocket(`ws://localhost:3000/ws/game/${this.currentRoomId}`);
                
                this.gameWs.onopen = () => {
                    console.log('Game WebSocket connected');
                };

                this.gameWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleGameMessage(data);
                    } catch (error) {
                        console.error('Error parsing game message:', error);
                    }
                };

                this.gameWs.onclose = () => {
                    console.log('Game WebSocket closed');
                };

                this.gameWs.onerror = (error) => {
                    console.error('Game WebSocket error:', error);
                };
            }

            handleLobbyMessage(data) {
                if (data.rooms) {
                    this.updateRoomList(data.rooms);
                    this.currentRoomId = data.currentRoomId;
                    
                    // Update current room display if we're in a room
                    if (this.currentRoomId) {
                        const currentRoom = data.rooms.find(r => r.isCurrentRoom);
                        if (currentRoom) {
                            this.isCreator = currentRoom.isCreator;
                            this.showCurrentRoom(currentRoom);

                             if (!this.gameWs || this.gameWs.readyState !== WebSocket.OPEN) {
                                console.log('Auto-reconnecting to game after page refresh');
                                this.connectGame();
                            }
                        }
                    }
                }

                if (data.success !== undefined) {
                    if (data.success && data.roomId) {
                        this.currentRoomId = data.roomId;
                        this.isCreator = data.isCreator || false;
                        this.showCurrentRoom(data.room);
                        console.log("here");
                        this.connectGame();
                        
                        // Refresh room list to get updated state
                        setTimeout(() => {
                            if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
                                this.lobbyWs.send('refresh');
                            }
                        }, 100);
                    } else if (!data.success) {
                        this.updateStatus(data.error || 'Operation failed', 'error');
                    }
                }

                // handle join specifically
                if (data.userJoined) {
                    this.showCurrentRoom(data.userJoined.room);  // ← Updates UI with new room state
                    
                    // Refresh room list to get updated state
                    setTimeout(() => {
                        if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
                            this.lobbyWs.send('refresh');
                        }
                    }, 100);
                }

                if (data.userLeft) {
                    this.showCurrentRoom(data.userLeft.room);  // ← Updates UI with new room state
                    
                    // Refresh room list to get updated state
                    setTimeout(() => {
                        if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
                            this.lobbyWs.send('refresh');
                        }
                    }, 100);
                }

                if (data.roomStateChanged) {
                    this.showCurrentRoom(data.roomStateChanged.room);
                    this.updateStatus(`Room marked as ${data.roomStateChanged.newState}`, 'success');
                    
                    // Refresh room list to get updated state
                    setTimeout(() => {
                        if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
                            this.lobbyWs.send('refresh');
                        }
                    }, 100);
                }

                // Same lobby WebSocket onmessage → handleLobbyMessage()
                if (data.type === 'started') {
                    this.overlay.innerHTML = '<div class="countdown">Game Starting...</div>';  // ← Shows overlay
                }
            }

            handleGameMessage(data) {
                console.log('Received game message:', data);
                
                if (data.type === 'gameFinished') {
                    console.log('Game finished with results:', data.gameResult);
                    this.gameState = { state: 'finished' };
                    this.gameResults = data.gameResult;
                    this.showGameResults(data.gameResult);
                }
                else if ((data.state !== undefined || data.ballPosition !== undefined)) {
                    this.gameState = data;
                    this.updateGameDisplay();
                    console.log('Game state updated:', this.gameState);
                }
            }

            showGameResults(gameResult) {
                let resultsHtml = '<div style="background: rgba(0,0,0,0.9); padding: 20px; border-radius: 8px; color: white; max-width: 400px;">';
                resultsHtml += '<h2 style="color: #00ff00; text-align: center; margin-top: 0;">Game Results</h2>';
                
                // Sort players by place
                const sortedPlayers = [...gameResult.players].sort((a, b) => {
                    if (a.place === '1') return -1;
                    if (b.place === '1') return 1;
                    return parseInt(a.place) - parseInt(b.place);
                });
                
                sortedPlayers.forEach((player, index) => {
                    const placeEmoji = player.place === '1' ? '🏆' : 
                                     player.place === '2' ? '🥈' : 
                                     player.place === '3' ? '🥉' : '📍';
                    
                    const statusColor = player.isActive ? '#00ff00' : '#ff4444';
                    resultsHtml += `
                        <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                            <span style="font-size: 20px;">${placeEmoji}</span>
                            <strong style="color: ${statusColor};">${player.username}</strong>
                            <br>
                            <small>Place: ${player.place} | Players eliminated: ${player.playersKicked || 0}</small>
                        </div>
                    `;
                });
                
                resultsHtml += '</div>';
                this.overlay.innerHTML = resultsHtml;
            }

            showGameEndRedirectMessage() {
                const currentContent = this.overlay.innerHTML;
                this.overlay.innerHTML = currentContent + 
                    '<div style="background: rgba(255,0,0,0.9); padding: 15px; margin-top: 20px; border-radius: 8px; text-align: center;">' +
                    '<h3 style="margin: 0; color: white;">Session Expired</h3>' +
                    '<p style="margin: 10px 0; color: white;">Your session has expired. You will be redirected to login in 10 seconds.</p>' +
                    '<p style="margin: 0; color: white; font-size: 12px;">You can refresh the page to login again.</p>' +
                    '</div>';
            }

            setupEventListeners() {
                // Create room
                document.getElementById('createRoomBtn').onclick = () => {
                    const entryFee = parseInt(document.getElementById('entryFee').value) || 0;
                    const maxPlayers = parseInt(document.getElementById('maxPlayers').value) || 4;
                    this.createRoom(entryFee, maxPlayers);
                };

                // Refresh rooms
                document.getElementById('refreshRoomsBtn').onclick = () => {
                    if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
                        this.lobbyWs.send(JSON.stringify({ type: 'getRooms' }));
                    }
                };

                // Leave room
                document.getElementById('leaveRoomBtn').onclick = () => {
                    this.leaveRoom();
                };

                // Start game
                document.getElementById('startGameBtn').onclick = () => {
                    this.startGame();
                };

                // Mark room ready
                document.getElementById('markReadyBtn').onclick = () => {
                    this.markRoomReady();
                };

                // Mark room waiting
                document.getElementById('markWaitingBtn').onclick = () => {
                    this.markRoomWaiting();
                };

                // Mouse movement for game - only when game is actually playing
                this.canvas.addEventListener('mousemove', (e) => {
                    // Only track and send input if game is in playing state
                    if (!this.gameState || this.gameState.state !== 'playing') {
                        // Update mouse position for smooth transition when game starts, but don't send
                        const rect = this.canvas.getBoundingClientRect();
                        this.mouseX = (e.clientX - rect.left) / rect.width;
                        return;
                    }

                    const rect = this.canvas.getBoundingClientRect();
                    const newMouseX = (e.clientX - rect.left) / rect.width;
                    
                    const deltaX = newMouseX - this.mouseX;
                    this.mouseX = newMouseX;
                    
                    // Only send if we have a meaningful delta and game WebSocket is ready
                    const now = Date.now();
                    if (Math.abs(deltaX) > 0.001 && // Only send if there's actual movement
                        this.gameWs && 
                        this.gameWs.readyState === WebSocket.OPEN && 
                        now - this.lastMouseUpdate > 16) {
                        
                        const scaledDelta = deltaX * 100;
                        this.gameWs.send(scaledDelta.toString());
                        this.lastMouseUpdate = now;
                        console.log(`Sent delta: ${scaledDelta} (game state: ${this.gameState.state})`);
                    }
                });
            }

            createRoom(entryFee, maxPlayers) {
                const ws = new WebSocket('ws://localhost:3000/ws/room/create');
                
                ws.onopen = () => {
                    ws.send(JSON.stringify({ entryFee, maxPlayers }));
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleLobbyMessage(data);
                    ws.close();
                };
            }

            joinRoom(roomId) {
                const ws = new WebSocket('ws://localhost:3000/ws/room/join');
                
                ws.onopen = () => {
                    ws.send(JSON.stringify({ roomId }));
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleLobbyMessage(data);
                    ws.close();
                };
            }

            leaveRoom() {
                if (!this.currentRoomId) return;

                const ws = new WebSocket('ws://localhost:3000/ws/room/leave');
                
                ws.onopen = () => {
                    ws.send(JSON.stringify({ roomId: this.currentRoomId }));
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.success) {
                        this.currentRoomId = null;
                        this.isCreator = false;
                        this.hideCurrentRoom();
                        if (this.gameWs) {
                            this.gameWs.close();
                            this.gameWs = null;
                        }
                    }
                    this.handleLobbyMessage(data);
                    ws.close();
                };
            }

            startGame() {
                if (!this.currentRoomId) return;

                const ws = new WebSocket(`ws://localhost:3000/ws/game/${this.currentRoomId}/start`);
                
                ws.onopen = () => {
                    ws.send('start');
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.success) {
                        this.updateStatus('Game started!', 'success');
                    } else {
                        this.updateStatus(data.error || 'Failed to start game', 'error');
                    }
                    ws.close();
                };
            }

            markRoomReady() {
                if (!this.currentRoomId) return;

                const ws = new WebSocket('ws://localhost:3000/ws/room/markReady');
                
                ws.onopen = () => {
                    ws.send('ready');
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.success) {
                        this.updateStatus('Room marked as ready', 'success');
                        // Refresh the lobby to get updated room state
                        if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
                            this.lobbyWs.send('refresh');
                        }
                    } else {
                        this.updateStatus(data.error || 'Failed to mark room as ready', 'error');
                    }
                    ws.close();
                };
            }

            markRoomWaiting() {
                if (!this.currentRoomId) return;

                // Use dedicated endpoint - no room ID needed, server determines it
                const ws = new WebSocket('ws://localhost:3000/ws/room/markWaiting');
                
                ws.onopen = () => {
                    ws.send('waiting'); // Simple message, server validates everything
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.success) {
                        this.updateStatus('Room marked as waiting', 'success');
                    } else {
                        this.updateStatus(data.error || 'Failed to mark room as waiting', 'error');
                    }
                    ws.close();
                };
            }

            updateRoomList(rooms) {
                const roomList = document.getElementById('roomList');
                roomList.innerHTML = '';

                rooms.forEach(room => {
                    const roomEl = document.createElement('div');
                    roomEl.className = 'room-item';
                    if (room.isCurrentRoom) {
                        roomEl.classList.add('current');
                    }

                    roomEl.innerHTML = `
                        <div><strong>Room ${room.id.substring(0, 8)}</strong></div>
                        <div>Players: ${room.players.length}/${room.maxPlayers}</div>
                        <div>Entry Fee: ${room.entryFee}</div>
                        <div>State: ${room.state}</div>
                        <div>Creator: ${room.creatorUsername}</div>
                    `;

                    if (!room.isCurrentRoom && room.state === 'waiting' && room.players.length < room.maxPlayers) {
                        roomEl.onclick = () => this.joinRoom(room.id);
                    }

                    roomList.appendChild(roomEl);
                });
            }

            showCurrentRoom(room) {
                if (!room) return;

                document.getElementById('currentRoom').style.display = 'block';
                
                const roomInfo = document.getElementById('roomInfo');
                roomInfo.innerHTML = `
                    <div><strong>Room ID:</strong> ${room.id.substring(0, 8)}</div>
                    <div><strong>Entry Fee:</strong> ${room.entryFee}</div>
                    <div><strong>Max Players:</strong> ${room.maxPlayers}</div>
                    <div><strong>State:</strong> ${room.state}</div>
                `;

                const playersList = document.getElementById('playersList');
                playersList.innerHTML = '<h5>Players:</h5>';
                room.players.forEach(player => {
                    const playerEl = document.createElement('div');
                    playerEl.className = 'player-item';
                    playerEl.textContent = player.username;
                    playersList.appendChild(playerEl);
                });

                // Show appropriate buttons for creator
                const markReadyBtn = document.getElementById('markReadyBtn');
                const markWaitingBtn = document.getElementById('markWaitingBtn');
                const startBtn = document.getElementById('startGameBtn');
                
                console.log('Button logic check:', {
                    isCreator: this.isCreator,
                    roomState: room.state,
                    playerCount: room.players.length,
                    hasEnoughPlayers: room.players.length >= 2
                });
                
                if (this.isCreator) {
                    if (room.state === 'waiting' && room.players.length >= 2) {
                        // Show "Mark Ready" button when waiting with enough players
                        markReadyBtn.style.display = 'inline-block';
                        markWaitingBtn.style.display = 'none';
                        startBtn.style.display = 'none';
                        console.log('Showing Mark Ready button');
                    } else if (room.state === 'ready') {
                        // Show "Mark Waiting" and "Start Game" buttons when ready
                        markReadyBtn.style.display = 'none';
                        markWaitingBtn.style.display = 'inline-block';
                        startBtn.style.display = 'inline-block';
                        console.log('Showing Mark Waiting and Start Game buttons');
                    } else {
                        // Hide all buttons when not enough players or other states
                        markReadyBtn.style.display = 'none';
                        markWaitingBtn.style.display = 'none';
                        startBtn.style.display = 'none';
                        console.log('Hiding all buttons - not enough players or wrong state');
                    }
                } else {
                    // Non-creators see no buttons
                    markReadyBtn.style.display = 'none';
                    markWaitingBtn.style.display = 'none';
                    startBtn.style.display = 'none';
                    console.log('Hiding all buttons - not creator');
                }
            }

            hideCurrentRoom() {
                document.getElementById('currentRoom').style.display = 'none';
                this.gameState = null;
                this.overlay.innerHTML = '';
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('connectionStatus');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            startRenderLoop() {
                const render = () => {
                    this.renderGame();
                    requestAnimationFrame(render);
                };
                render();
            }

            renderGame() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!this.gameState) {
                    // Draw empty arena
                    this.drawArena(ctx, canvas);
                    return;
                }

                // Draw arena
                this.drawArena(ctx, canvas);

                // Draw ball
                if (this.gameState.ballPosition) {
                    this.drawBall(ctx, canvas, this.gameState.ballPosition);
                }

                // Draw players
                if (this.gameState.players) {
                    this.drawPlayers(ctx, canvas, this.gameState.players);
                }
            }

            drawArena(ctx, canvas) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 2 - 20;

                // Draw outer circle
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw center dot
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            drawBall(ctx, canvas, ballPos) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 2 - 20;

                const ballX = centerX + ballPos[0] * radius;
                const ballY = centerY + ballPos[1] * radius;

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(ballX, ballY, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            drawPlayers(ctx, canvas, players) {
                if (!players || players.length === 0) {
                    console.log('No players to draw');
                    return;
                }

                console.log('Drawing players:', players);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 2 - 20;
                const playerCount = players.length;
                const alpha = (Math.PI * 2) / playerCount;
                const height = 0.5 / Math.tan(alpha / 2);
                const paddleWidth = 0.1;

                players.forEach((player, index) => {
                    const beta = alpha * index;
                    const gamma = beta - (Math.PI / 2);

                    // Calculate paddle position
                    const distance = player.position - 0.5;
                    const distance_x = distance * Math.cos(beta);
                    const distance_y = distance * Math.sin(beta);
                    const x_center = height * Math.cos(gamma);
                    const y_center = height * Math.sin(gamma);
                    const paddleX = x_center + distance_x;
                    const paddleY = y_center + distance_y;

                    // Draw paddle
                    const screenX = centerX + paddleX * radius;
                    const screenY = centerY + paddleY * radius;
                    
                    const leftX = screenX - paddleWidth * Math.cos(beta) * radius;
                    const leftY = screenY - paddleWidth * Math.sin(beta) * radius;
                    const rightX = screenX + paddleWidth * Math.cos(beta) * radius;
                    const rightY = screenY + paddleWidth * Math.sin(beta) * radius;

                    ctx.strokeStyle = player.isActive ? '#00ff00' : '#ff4444';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(leftX, leftY);
                    ctx.lineTo(rightX, rightY);
                    ctx.stroke();

                    // Draw player name
                    ctx.fillStyle = player.isActive ? '#00ff00' : '#ff4444';
                    ctx.font = '12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.username, screenX, screenY - 20);
                });
            }
        }

        // Initialize the game client when page loads
        window.addEventListener('load', () => {
            new GameClient();
        });
    </script>
</body>
</html>