"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;





















var _chunkGNQW3RZHcjs = require('./chunk-GNQW3RZH.cjs');

// src/server.js
var _assert = require('assert'); var _assert2 = _interopRequireDefault(_assert);
var _promises = require('dns/promises'); var _promises2 = _interopRequireDefault(_promises);
var _fs = require('fs');
var _http = require('http');
var _eventemitter3 = require('eventemitter3');
var _ipaddrjs = require('ipaddr.js'); var _ipaddrjs2 = _interopRequireDefault(_ipaddrjs);
var _tempy = require('tempy');
var _uWebSocketsjs = require('uWebSockets.js'); var _uWebSocketsjs2 = _interopRequireDefault(_uWebSocketsjs);





















var noop = () => {
};
function createApp(https) {
  if (!https)
    return _uWebSocketsjs2.default.App();
  if (!https.key)
    return _uWebSocketsjs2.default.SSLApp(https);
  const keyFile = _tempy.temporaryFile.call(void 0, );
  _fs.writeFileSync.call(void 0, keyFile, https.key);
  const certFile = _tempy.temporaryFile.call(void 0, );
  _fs.writeFileSync.call(void 0, certFile, https.cert);
  return _uWebSocketsjs2.default.SSLApp({
    key_file_name: keyFile,
    cert_file_name: certFile,
    passphrase: https.passphrase
  });
}
var VALID_METHODS = new Map(_http.METHODS.map((method) => [method.toLowerCase(), method]));
var mainServer = {};
var Server = (_class = class extends _eventemitter3.EventEmitter {
  /**
   * @param {(req: Request, res: Response) => void} handler
   * @param {ServerOptions} opts
   */
  constructor(handler, opts = {}) {
    super();_class.prototype.__init.call(this);_class.prototype.__init2.call(this);;
    const { connectionTimeout = 0, https = false } = opts;
    _assert2.default.call(void 0, 
      !https || typeof https === "object",
      "https must be a valid object { key: string, cert: string } or follow the uws.AppOptions"
    );
    this[_chunkGNQW3RZHcjs.kHandler] = handler;
    this.timeout = connectionTimeout;
    this[_chunkGNQW3RZHcjs.kHttps] = https;
    this[_chunkGNQW3RZHcjs.kWs] = null;
    this[_chunkGNQW3RZHcjs.kAddress] = null;
    this[_chunkGNQW3RZHcjs.kListenSocket] = null;
    this[_chunkGNQW3RZHcjs.kApp] = createApp(this[_chunkGNQW3RZHcjs.kHttps]);
    this[_chunkGNQW3RZHcjs.kClosed] = false;
    this[_chunkGNQW3RZHcjs.kListenAll] = false;
    this[_chunkGNQW3RZHcjs.kListening] = false;
  }
  /** @type {boolean} */
  get encrypted() {
    return !!this[_chunkGNQW3RZHcjs.kHttps];
  }
  /** @type {boolean} */
  get listening() {
    return this[_chunkGNQW3RZHcjs.kListening];
  }
  /**
   * @param {number} timeout
   */
  setTimeout(timeout) {
    this.timeout = timeout;
  }
  /**
   * @returns {{ address: string, port: number }}
   */
  address() {
    return this[_chunkGNQW3RZHcjs.kAddress];
  }
  /**
   *
   * @param {{
   *   host: string
   *   port: number
   *   signal: AbortSignal
   * }} listenOptions
   */
  listen(listenOptions) {
    if (_optionalChain([listenOptions, 'optionalAccess', _ => _.signal])) {
      listenOptions.signal.addEventListener("abort", () => {
        this.close();
      });
    }
    this[_chunkGNQW3RZHcjs.kListen](listenOptions).then(() => {
      this[_chunkGNQW3RZHcjs.kListening] = true;
      this.emit("listening");
    }).catch((err) => {
      this[_chunkGNQW3RZHcjs.kAddress] = null;
      process.nextTick(() => this.emit("error", err));
    });
  }
  closeIdleConnections() {
    this.close();
  }
  /**
   * @param {() => void} [cb]
   */
  close(cb = noop) {
    this[_chunkGNQW3RZHcjs.kAddress] = null;
    this[_chunkGNQW3RZHcjs.kListening] = false;
    if (this[_chunkGNQW3RZHcjs.kClosed])
      return cb();
    const port = _optionalChain([this, 'access', _2 => _2[_chunkGNQW3RZHcjs.kAddress], 'optionalAccess', _3 => _3.port]);
    if (port !== void 0 && mainServer[port] === this) {
      delete mainServer[port];
    }
    this[_chunkGNQW3RZHcjs.kClosed] = true;
    if (this[_chunkGNQW3RZHcjs.kListenSocket]) {
      _uWebSocketsjs2.default.us_listen_socket_close(this[_chunkGNQW3RZHcjs.kListenSocket]);
      this[_chunkGNQW3RZHcjs.kListenSocket] = null;
    }
    if (this[_chunkGNQW3RZHcjs.kWs]) {
      this[_chunkGNQW3RZHcjs.kWs].connections.forEach((conn) => conn.close());
    }
    process.nextTick(() => {
      this.emit("close");
      cb();
    });
  }
  __init() {this.ref = noop}
  __init2() {this.unref = noop}
  async [_chunkGNQW3RZHcjs.kListen]({ port, host }) {
    if (this[_chunkGNQW3RZHcjs.kClosed])
      throw new (0, _chunkGNQW3RZHcjs.ERR_SERVER_DESTROYED)();
    if (port !== void 0 && port !== null && Number.isNaN(Number(port))) {
      throw new (0, _chunkGNQW3RZHcjs.ERR_SOCKET_BAD_PORT)(port);
    }
    port = port === void 0 || port === null ? 0 : Number(port);
    const lookupAddress = await _promises2.default.lookup(host);
    this[_chunkGNQW3RZHcjs.kAddress] = {
      ...lookupAddress,
      port
    };
    if (this[_chunkGNQW3RZHcjs.kAddress].family === 4) {
      this[_chunkGNQW3RZHcjs.kAddress].family = "IPv4";
    }
    if (this[_chunkGNQW3RZHcjs.kAddress].family === 6) {
      this[_chunkGNQW3RZHcjs.kAddress].family = "IPv6";
    }
    if (this[_chunkGNQW3RZHcjs.kAddress].address.startsWith("[")) {
      throw new (0, _chunkGNQW3RZHcjs.ERR_ENOTFOUND)(this[_chunkGNQW3RZHcjs.kAddress].address);
    }
    if (mainServer[port] && host !== "localhost" && mainServer[port][_chunkGNQW3RZHcjs.kListenAll])
      return;
    const parsedAddress = _ipaddrjs2.default.parse(this[_chunkGNQW3RZHcjs.kAddress].address);
    const longAddress = parsedAddress.toNormalizedString();
    const app = this[_chunkGNQW3RZHcjs.kApp];
    const onRequest = (res, req) => {
      const method = VALID_METHODS.get(req.getMethod());
      const socket = new (0, _chunkGNQW3RZHcjs.HTTPSocket)(
        this,
        res,
        method === "GET" || method === "HEAD"
      );
      if (!method) {
        socket[_chunkGNQW3RZHcjs.kClientError] = true;
        this.emit("clientError", new (0, _chunkGNQW3RZHcjs.ERR_INVALID_METHOD)(), socket);
        return;
      }
      const request = new (0, _chunkGNQW3RZHcjs.Request)(req, socket, method);
      const response = new (0, _chunkGNQW3RZHcjs.Response)(socket);
      if (request.headers.upgrade) {
        if (this[_chunkGNQW3RZHcjs.kWs])
          return;
        this.emit("upgrade", request, socket);
        return;
      }
      this[_chunkGNQW3RZHcjs.kHandler](request, response);
    };
    app.any("/*", onRequest);
    if (port !== 0 && mainServer[port]) {
      this[_chunkGNQW3RZHcjs.kWs] = mainServer[port][_chunkGNQW3RZHcjs.kWs];
    }
    if (this[_chunkGNQW3RZHcjs.kWs]) {
      this[_chunkGNQW3RZHcjs.kWs].addServer(this);
    }
    return new Promise((resolve, reject) => {
      const onListen = (listenSocket) => {
        if (!listenSocket) {
          return reject(new (0, _chunkGNQW3RZHcjs.ERR_ADDRINUSE)(this[_chunkGNQW3RZHcjs.kAddress].address, port));
        }
        this[_chunkGNQW3RZHcjs.kListenSocket] = listenSocket;
        port = this[_chunkGNQW3RZHcjs.kAddress].port = _uWebSocketsjs2.default.us_socket_local_port(listenSocket);
        if (!mainServer[port]) {
          mainServer[port] = this;
        }
        resolve();
      };
      this[_chunkGNQW3RZHcjs.kListenAll] = host === "localhost";
      if (this[_chunkGNQW3RZHcjs.kListenAll]) {
        app.listen(port, onListen);
      } else {
        app.listen(longAddress, port, onListen);
      }
    });
  }
}, _class);
var serverFactory = (handler, opts) => {
  return new Server(handler, opts);
};
var getUws = (fastify) => {
  const { server } = fastify;
  if (!server[_chunkGNQW3RZHcjs.kApp])
    throw new (0, _chunkGNQW3RZHcjs.ERR_UWS_APP_NOT_FOUND)();
  return server[_chunkGNQW3RZHcjs.kApp];
};
























exports.DEDICATED_COMPRESSOR_128KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_128KB; exports.DEDICATED_COMPRESSOR_16KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_16KB; exports.DEDICATED_COMPRESSOR_256KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_256KB; exports.DEDICATED_COMPRESSOR_32KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_32KB; exports.DEDICATED_COMPRESSOR_3KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_3KB; exports.DEDICATED_COMPRESSOR_4KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_4KB; exports.DEDICATED_COMPRESSOR_64KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_64KB; exports.DEDICATED_COMPRESSOR_8KB = _uWebSocketsjs.DEDICATED_COMPRESSOR_8KB; exports.DEDICATED_DECOMPRESSOR = _uWebSocketsjs.DEDICATED_DECOMPRESSOR; exports.DEDICATED_DECOMPRESSOR_16KB = _uWebSocketsjs.DEDICATED_DECOMPRESSOR_16KB; exports.DEDICATED_DECOMPRESSOR_1KB = _uWebSocketsjs.DEDICATED_DECOMPRESSOR_1KB; exports.DEDICATED_DECOMPRESSOR_2KB = _uWebSocketsjs.DEDICATED_DECOMPRESSOR_2KB; exports.DEDICATED_DECOMPRESSOR_32KB = _uWebSocketsjs.DEDICATED_DECOMPRESSOR_32KB; exports.DEDICATED_DECOMPRESSOR_4KB = _uWebSocketsjs.DEDICATED_DECOMPRESSOR_4KB; exports.DEDICATED_DECOMPRESSOR_512B = _uWebSocketsjs.DEDICATED_DECOMPRESSOR_512B; exports.DEDICATED_DECOMPRESSOR_8KB = _uWebSocketsjs.DEDICATED_DECOMPRESSOR_8KB; exports.DISABLED = _uWebSocketsjs.DISABLED; exports.SHARED_COMPRESSOR = _uWebSocketsjs.SHARED_COMPRESSOR; exports.SHARED_DECOMPRESSOR = _uWebSocketsjs.SHARED_DECOMPRESSOR; exports.Server = Server; exports.WebSocketStream = _chunkGNQW3RZHcjs.WebSocketStream; exports.getUws = getUws; exports.serverFactory = serverFactory;
